generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite" // Cambiar a "postgresql" si migr√°s a Postgres
  url      = env("DATABASE_URL")
}

model Patient {
  id             String                @id @default(cuid())
  dni            String                @unique
  firstName      String
  lastName       String
  birthDate      DateTime
  sex            String // "F" | "M" |
  phone          String?
  email          String?
  address        String?
  obraSocial     String?
  codigoAfiliado String?
  notes          String?
  diabetico      Boolean?
  tiroides       Boolean?
  accountEntries PatientAccountEntry[] // para las cuentas
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt

  orders TestOrder[]
}

model Doctor {
  id            String  @id @default(cuid())
  fullName      String
  licenseNumber String? @unique
  phone         String?
  email         String? @unique

  orders TestOrder[]
}

model TestOrder {
  id          String   @id @default(cuid())
  patientId   String
  doctorId    String?
  status      String   @default("PENDING") // PENDING | COMPLETED | CANCELED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt
  notes       String?
  orderNumber String?  @unique
  title       String?

  methodPay String?

  patient Patient @relation(fields: [patientId], references: [id],onDelete: Cascade)
  doctor  Doctor? @relation(fields: [doctorId], references: [id])

  items   OrderItem[]
  samples Sample[]

  // üîÅ back-relation para saldar el error
  accountEntries PatientAccountEntry[]
}

model Sample {
  id          String    @id @default(cuid())
  orderId     String
  sampleType  String // BLOOD | URINE | STOOL | SALIVA | OTHER
  collectedAt DateTime?
  notes       String?

  order TestOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Result {
  id          String   @id @default(cuid())
  orderItemId String   @unique
  value       String
  observedAt  DateTime @default(now())
  unit        String?
  refRange    String?

  orderItem OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)

  @@index([orderItemId])
}

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  passwordHash String
  role         String   @default("OPERATOR") // ADMIN | OPERATOR | VIEWER
  createdAt    DateTime @default(now())
}

model Nomenclador {
  id            String @id @default(cuid())
  codigo        Int    @unique // ej: 660002
  determinacion String // ej: ACETONURIA
  ub            Float // ej: 1, 3, 12.5

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Cada c√≥digo (660042, etc.)
model ExamType {
  id      String  @id @default(cuid())
  code    String  @unique
  name    String
  isPanel Boolean @default(false)

  items      ExamItemDef[]
  orderItems OrderItem[]
}

// Definici√≥n de los √≠tems a completar para un c√≥digo (nombre/unidad fijos)
model ExamItemDef {
  id         String   @id @default(cuid())
  examTypeId String
  examType   ExamType @relation(fields: [examTypeId], references: [id], onDelete: Cascade)

  key   String // identificador interno
  label String // etiqueta visible
  unit  String? // "U/L"

  sortOrder Int      @default(0)
  refText   String? // ‚Äú0.70‚Äì1.20 mg/dL‚Äù, ‚ÄúNegativo‚Äù, ‚ÄúNo reactivas‚Äù, etc.
  method    String?  @default("N/A")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  kind     String?
  analytes OrderItemAnalyte[]

  @@unique([examTypeId, key])
}

// Instancia de un c√≥digo dentro de una orden
model OrderItem {
  id         String   @id @default(cuid())
  orderId    String
  examTypeId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  order    TestOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  examType ExamType  @relation(fields: [examTypeId], references: [id])

  analytes OrderItemAnalyte[]
  results  Result[]

  // üí∞ pasar a centavos
  priceCents          Int? // antes: Decimal? @db.Decimal(10,2)
  paidAtCreationCents Int  @default(0) // antes: Decimal? @db.Decimal(10,2)

  // üîÅ back-relation necesaria (ver error 2)
  accountEntries PatientAccountEntry[]
}

// Resultado por sub-√≠tem (instancias a completar en esa orden)
model OrderItemAnalyte {
  id          String @id @default(cuid())
  orderItemId String
  itemDefId   String

  orderItem OrderItem   @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  itemDef   ExamItemDef @relation(fields: [itemDefId], references: [id])

  // valor cargado
  valueNum  Float?
  valueText String?
  status    String  @default("PENDING") // "PENDING"|"DONE"
  comment   String?

  // snapshot de unidad y referencias al momento de crear la orden
  unit        String?
  refLow      Float?
  refHigh     Float?
  refExpected String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderItemId])
  @@index([itemDefId])
}

model SocialWork {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// cuenta paciente

enum AccountEntryKind {
  CHARGE
  PAYMENT
  ADJUSTMENT
}

model PatientAccountEntry {
  id        String           @id @default(cuid())
  patientId String
  kind      AccountEntryKind

  // üí∞ en centavos
  amountCents Int

  description String?
  createdAt   DateTime @default(now())

  testOrderId String?
  orderItemId String?

  patient   Patient    @relation(fields: [patientId], references: [id], onDelete: Cascade)
  testOrder TestOrder? @relation(fields: [testOrderId], references: [id], onDelete: SetNull)
  orderItem OrderItem? @relation(fields: [orderItemId], references: [id], onDelete: SetNull)

  @@index([patientId])
  @@index([testOrderId])
  @@index([orderItemId])
}
